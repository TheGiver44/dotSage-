import { ApiPromise, WsProvider } from "@polkadot/api";
import { ContractPromise, Abi } from "@polkadot/api-contract";
import CONTRACT_METADATA_JSON from "./contract_metadata.json";

// Contract metadata is generated by the ink! build and copied into this JSON file by the setup script.
const CONTRACT_METADATA: Record<string, unknown> = CONTRACT_METADATA_JSON as unknown as Record<string, unknown>;

/**
 * Checks if an error message indicates insufficient balance for transaction fees
 */
function isInsufficientBalanceError(errorMessage: string): boolean {
	const lowerMessage = errorMessage.toLowerCase();
	return (
		lowerMessage.includes("1010") ||
		lowerMessage.includes("inability to pay") ||
		lowerMessage.includes("account balance too low") ||
		lowerMessage.includes("insufficient balance") ||
		lowerMessage.includes("cannot pay fees")
	);
}

/**
 * Formats an error message, providing user-friendly messages for common errors
 */
function formatErrorMessage(error: unknown): string {
	const errorMsg = error instanceof Error ? error.message : String(error);
	
	if (isInsufficientBalanceError(errorMsg)) {
		return "Insufficient balance: Your account doesn't have enough funds to pay transaction fees. Please fund your account with tokens (e.g., DOT or the local test token) and try again. For local development, you can use the Polkadot.js Apps faucet or transfer tokens from another account.";
	}
	
	return errorMsg;
}

type InitConfig = {
	wsUrl: string;
	contractAddress: string;
};

let apiPromise: ApiPromise | null = null;
let contract: ContractPromise | null = null;
let currentConfig: InitConfig | null = null;

/**
 * Gets or creates an ApiPromise instance for blockchain interactions.
 * Implements connection pooling and timeout handling to prevent hanging connections.
 * 
 * @param config - Configuration containing WebSocket URL
 * @returns Promise resolving to an ApiPromise instance
 * @throws Error if connection fails or times out
 */
async function getApi(config: InitConfig): Promise<ApiPromise> {
	// Reuse existing API instance if config hasn't changed (connection pooling)
	if (apiPromise && currentConfig?.wsUrl === config.wsUrl) return apiPromise;
	
	const provider = new WsProvider(config.wsUrl);
	
	// Add connection timeout (10 seconds) and better error handling
	try {
		apiPromise = await Promise.race([
			ApiPromise.create({ provider }),
			new Promise<never>((_, reject) => 
				setTimeout(() => reject(new Error("Connection timeout: Unable to connect to blockchain node. Make sure the contracts node is running on " + config.wsUrl)), 10000)
			)
		]);
		currentConfig = { ...currentConfig, wsUrl: config.wsUrl } as InitConfig;
		return apiPromise;
	} catch (error) {
		const errorMessage = error instanceof Error ? error.message : String(error);
		// Provide helpful error messages for common connection issues
		if (errorMessage.includes("ECONNREFUSED") || errorMessage.includes("failed") || errorMessage.includes("timeout")) {
			throw new Error(`Cannot connect to blockchain node at ${config.wsUrl}. Please start the contracts node:\n\nsubstrate-contracts-node --dev --tmp\n\nOr check if the node is running on the correct port.`);
		}
		throw error;
	}
}

/**
 * Gets or creates a ContractPromise instance for interacting with the smart contract.
 * Uses singleton pattern to reuse contract instances and avoid redundant initialization.
 * 
 * @param config - Configuration containing WebSocket URL and contract address
 * @returns Promise resolving to a ContractPromise instance
 */
async function getContract(config: InitConfig): Promise<ContractPromise> {
	const api = await getApi(config);
	if (contract && currentConfig?.contractAddress === config.contractAddress) return contract;
	contract = new ContractPromise(api, CONTRACT_METADATA as Record<string, unknown>, config.contractAddress);
	currentConfig = config;
	return contract;
}

/**
 * Subscribes to contract events for real-time updates.
 * This enables reactive UI updates without polling, reducing RPC calls and improving UX.
 * 
 * Uses Polkadot's event subscription system to listen for ContractEmitted events
 * from the smart contract and decode them using the contract ABI.
 * 
 * @param config - Configuration containing WebSocket URL and contract address
 * @param onQuestionAsked - Callback when a new question is asked
 * @param onQuestionVoted - Callback when a question is voted on
 * @returns Unsubscribe function to stop listening to events
 */
export function subscribeToContractEvents(
	config: InitConfig,
	onQuestionAsked?: (event: { id: number; author: string; category: string }) => void,
	onQuestionVoted?: (event: { id: number; voter: string; isUp: boolean }) => void
): () => void {
	let unsubscribe: (() => void) | null = null;
	
	void (async () => {
		try {
			const api = await getApi(config);
			const abi = new Abi(CONTRACT_METADATA);
			const contractAddressBytes = api.createType("AccountId", config.contractAddress);
			
			// Subscribe to all system events and filter for our contract's events
			unsubscribe = await api.query.system.events((events) => {
				events.forEach((record) => {
					const { event } = record;
					
					// Check if this is a ContractEmitted event
					if (api.events.contracts.ContractEmitted.is(event)) {
						const [contractId, contractEvent] = event.data;
						
						// Only process events from our contract (compare as AccountId)
						if (!contractId.eq(contractAddressBytes)) return;
						
						// Decode the event data using ABI
						try {
							const decoded = abi.decodeEvent(contractEvent);
							
							// Handle QuestionAsked event
							if (decoded.name === "QuestionAsked" && onQuestionAsked) {
								const args = decoded.args as any;
								onQuestionAsked({
									id: Number(args.id),
									author: args.author.toString(),
									category: args.category.toString(),
								});
							}
							
							// Handle QuestionVoted event
							if (decoded.name === "QuestionVoted" && onQuestionVoted) {
								const args = decoded.args as any;
								onQuestionVoted({
									id: Number(args.id),
									voter: args.voter.toString(),
									isUp: Boolean(args.is_up),
								});
							}
						} catch (error) {
							// Silently fail on decode errors (event might be from another contract)
							console.debug("Failed to decode event:", error);
						}
					}
				});
			});
		} catch (error) {
			console.error("Failed to subscribe to contract events:", error);
		}
	})();
	
	// Return unsubscribe function
	return () => {
		if (unsubscribe) {
			unsubscribe();
		}
	};
}

export type LogQuestionArgs = {
	text: string;
	category: "Docs" | "Builders" | "Governance" | "Ecosystem";
	createdAtMs: number;
};

/**
 * Logs a question to the blockchain via the ink! smart contract.
 * 
 * This function:
 * 1. Enables wallet extensions and gets accounts
 * 2. Gets the contract instance and signer injector
 * 3. Calls the contract's askQuestion method with proper gas limits
 * 4. Signs and sends the transaction
 * 5. Returns the transaction hash for tracking
 * 
 * @param args - Question arguments (text, category, createdAtMs)
 * @returns Promise resolving to transaction hash
 * @throws Error if wallet connection fails, contract call fails, or transaction errors
 */
export async function logQuestionOnChain(args: LogQuestionArgs): Promise<string> {
	const config = getDefaultConfig();
	
	// Validate config
	if (!config.wsUrl || config.wsUrl.includes("xxxxxxxx")) {
		throw new Error(`Invalid RPC URL: ${config.wsUrl}. Check NEXT_PUBLIC_WS_URL env var.`);
	}
	if (!config.contractAddress || config.contractAddress.includes("xxxxxxxx")) {
		throw new Error(`Invalid contract address: ${config.contractAddress}. Check NEXT_PUBLIC_CONTRACT_ADDRESS env var.`);
	}

	const api = await getApi(config);
	const c = await getContract(config);

	if (typeof window === "undefined") {
		throw new Error("Wallet actions require a browser environment");
	}
	
	const { web3Enable, web3Accounts, web3FromSource } = await import("@polkadot/extension-dapp");
	
	// Enable all extensions
	const extensions = await web3Enable("DotSage");
	if (!extensions || extensions.length === 0) {
		throw new Error("No Polkadot wallet extension found. Please install Polkadot.js Extension or Talisman and refresh the page.");
	}
	
	// Get all accounts from all extensions
	const allAccounts = await web3Accounts();
	if (!allAccounts || allAccounts.length === 0) {
		const extensionNames = extensions.map(ext => ext.name).join(", ");
		throw new Error(`No accounts found in your wallet extensions (${extensionNames}). Please create or import an account in your wallet extension.`);
	}
	
	// Use the first account from web3Accounts (we already validated it exists)
	const firstAccount = allAccounts[0];
	if (!firstAccount || !firstAccount.meta || !firstAccount.meta.source) {
		throw new Error("Invalid account data. Please ensure your wallet extension is properly configured.");
	}
	if (!firstAccount.address) {
		throw new Error("Invalid account address. Please ensure your wallet has a valid account.");
	}
	
	const accountSource = firstAccount.meta.source;
	
	// Get the injector for signing (we don't need injector.accounts, we already have the account)
	const injector = await web3FromSource(accountSource);
	if (!injector) {
		throw new Error(`Failed to get wallet injector from ${accountSource}. Please ensure your wallet extension is enabled and try again.`);
	}
	
	if (!injector.signer) {
		throw new Error("No signer available. Please ensure your wallet extension supports signing transactions.");
	}
	
	// Use the account from web3Accounts directly (injector.accounts may be empty but that's okay)
	const account = {
		address: firstAccount.address,
		meta: firstAccount.meta,
	};

	const catIndex = categoryToIndex(args.category);
	const createdAt = BigInt(args.createdAtMs);
	const gasLimit = api.registry.createType("WeightV2", {
		refTime: 1800000000,
		proofSize: 0,
	});
	const storageDepositLimit = null;

	// askQuestion(text: String, category: Category, created_at: u64)
	// Access the contract method directly by name (camelCase)
	const txMethod = (c.tx as Record<string, unknown>)['askQuestion'];
	
	if (typeof txMethod !== 'function') {
		const availableMethods = Object.keys(c.tx).filter(key => typeof (c.tx as Record<string, unknown>)[key] === 'function').join(', ');
		throw new Error(`Contract method 'askQuestion' is not a function. Available methods: ${availableMethods || 'none'}`);
	}

	return new Promise<string>((resolve, reject) => {
		txMethod({ gasLimit, storageDepositLimit }, args.text, catIndex, createdAt)
			.signAndSend(account.address, { signer: injector.signer }, ({ status, txHash, dispatchError }: {
				status: { isInBlock: boolean; isFinalized: boolean };
				txHash: { toString: () => string };
				dispatchError?: { isModule: boolean; asModule: unknown; toString: () => string };
			}) => {
				if (dispatchError) {
					let errorMsg: string;
					if (dispatchError.isModule && dispatchError.asModule) {
						try {
							// @ts-expect-error - asModule type is complex, but findMetaError handles it
							const decoded = api.registry.findMetaError(dispatchError.asModule);
							errorMsg = decoded ? `${decoded.section}.${decoded.name}: ${decoded.docs.join(' ')}` : dispatchError.toString();
						} catch {
							errorMsg = dispatchError.toString();
						}
					} else {
						errorMsg = dispatchError.toString();
					}
					reject(new Error(formatErrorMessage(`Transaction failed: ${errorMsg}`)));
					return;
				}
				if (status.isInBlock || status.isFinalized) {
					resolve(txHash.toString());
				}
			})
			.catch((err: unknown) => {
				reject(new Error(formatErrorMessage(err)));
			});
	});
}

/**
 * Fetches questions from the blockchain contract.
 * 
 * Uses a dry-run query (no transaction fees) to read contract state.
 * This is the recommended pattern for reading data from ink! contracts.
 * 
 * @param params - Query parameters (offset for pagination, limit for batch size)
 * @returns Promise resolving to array of questions with metadata
 * @throws Error if contract query fails or connection issues occur
 */
export async function fetchRecentQuestions(params: { offset: number; limit: number }): Promise<
	Array<{
		id: number;
		author: string;
		text: string;
		category: "Docs" | "Builders" | "Governance" | "Ecosystem";
		createdAt: number;
		upvotes: number;
		downvotes: number;
	}>
> {
	const config = getDefaultConfig();
	
	// Validate config
	if (!config.wsUrl || config.wsUrl.includes("xxxxxxxx")) {
		throw new Error(`Invalid RPC URL: ${config.wsUrl}. Check NEXT_PUBLIC_WS_URL env var.`);
	}
	if (!config.contractAddress || config.contractAddress.includes("xxxxxxxx")) {
		throw new Error(`Invalid contract address: ${config.contractAddress}. Check NEXT_PUBLIC_CONTRACT_ADDRESS env var.`);
	}

	try {
		const c = await getContract(config);
		// getQuestions(offset: u32, limit: u32) -> Vec<Question>
		const gasLimit = c.api.registry.createType("WeightV2", { refTime: 1800000000, proofSize: 0 });
		// @ts-expect-error method exists in metadata, gasLimit type is compatible at runtime
		const { result, output } = await c.query.getQuestions(
			// address param is unused for dry query; pass contract address
			config.contractAddress,
			// @ts-expect-error - gasLimit is compatible WeightV2 type at runtime
			{ gasLimit },
			params.offset,
			params.limit
		);
		if (result.isErr || !output) {
			return [];
		}
		// Output decoding depends on metadata; here we map to typed structure.
		const decoded = (output.toJSON() as Array<any>) ?? [];
		return decoded.map((q: any) => ({
			id: Number(q.id),
			author: String(q.author),
			text: String(q.text),
			category: indexToCategory(Number(q.category)),
			createdAt: Number(q.created_at),
			upvotes: Number(q.upvotes),
			downvotes: Number(q.downvotes),
		}));
	} catch (error) {
		const errorMessage = error instanceof Error ? error.message : String(error);
		if (errorMessage.includes("ECONNREFUSED") || errorMessage.includes("failed") || errorMessage.includes("timeout") || errorMessage.includes("Cannot connect")) {
			throw new Error(`Cannot connect to blockchain node at ${config.wsUrl}. Please start the contracts node:\n\nsubstrate-contracts-node --dev --tmp\n\nOr check if the node is running on the correct port.`);
		}
		throw error;
	}
}

export async function voteOnQuestion(params: { id: number; isUp: boolean }): Promise<string> {
	const config = getDefaultConfig();
	
	// Validate config
	if (!config.wsUrl || config.wsUrl.includes("xxxxxxxx")) {
		throw new Error(`Invalid RPC URL: ${config.wsUrl}. Check NEXT_PUBLIC_WS_URL env var.`);
	}
	if (!config.contractAddress || config.contractAddress.includes("xxxxxxxx")) {
		throw new Error(`Invalid contract address: ${config.contractAddress}. Check NEXT_PUBLIC_CONTRACT_ADDRESS env var.`);
	}

	try {
		const api = await getApi(config);
		const c = await getContract(config);
		if (typeof window === "undefined") {
			throw new Error("Wallet actions require a browser environment");
		}
		const { web3Enable, web3Accounts, web3FromSource } = await import("@polkadot/extension-dapp");
		
		// Enable all extensions
		const extensions = await web3Enable("DotSage");
		if (!extensions || extensions.length === 0) {
			throw new Error("No wallet extension found. Please install Polkadot.js Extension or Talisman.");
		}
		
		// Get all accounts from all extensions
		const allAccounts = await web3Accounts();
		if (!allAccounts || allAccounts.length === 0) {
			const extensionNames = extensions.map(ext => ext.name).join(", ");
			throw new Error(`No accounts found in your wallet extensions (${extensionNames}). Please create or import an account.`);
		}
		
		// Use the first account from web3Accounts (we already validated it exists)
		const firstAccount = allAccounts[0];
		if (!firstAccount || !firstAccount.meta || !firstAccount.meta.source) {
			throw new Error("Invalid account data. Please ensure your wallet extension is properly configured.");
		}
		if (!firstAccount.address) {
			throw new Error("Invalid account address. Please ensure your wallet has a valid account.");
		}
		
		const accountSource = firstAccount.meta.source;
		
		// Get the injector for signing (we don't need injector.accounts, we already have the account)
		const injector = await web3FromSource(accountSource);
		if (!injector) {
			throw new Error(`Failed to get wallet injector from ${accountSource}. Please ensure your wallet extension is enabled.`);
		}
		
		if (!injector.signer) {
			throw new Error("No signer available. Please ensure your wallet extension supports signing transactions.");
		}
		
		// Use the account from web3Accounts directly (injector.accounts may be empty but that's okay)
		const account = {
			address: firstAccount.address,
			meta: firstAccount.meta,
		};

		const gasLimit = api.registry.createType("WeightV2", {
			refTime: 1200000000,
			proofSize: 0,
		});
		const storageDepositLimit = null;

		// Access the contract method directly by name
		const txMethod = (c.tx as Record<string, unknown>)['vote'];
		
		if (typeof txMethod !== 'function') {
			const availableMethods = Object.keys(c.tx).filter(key => typeof (c.tx as Record<string, unknown>)[key] === 'function').join(', ');
			throw new Error(`Contract method 'vote' is not a function. Available methods: ${availableMethods || 'none'}`);
		}

		return new Promise<string>((resolve, reject) => {
			txMethod({ gasLimit, storageDepositLimit }, params.id, params.isUp)
				.signAndSend(account.address, { signer: injector.signer }, ({ status, txHash, dispatchError }: {
					status: { isInBlock: boolean; isFinalized: boolean };
					txHash: { toString: () => string };
					dispatchError?: { toString: () => string };
				}) => {
					if (dispatchError) {
						reject(new Error(formatErrorMessage(dispatchError.toString())));
						return;
					}
					if (status.isInBlock || status.isFinalized) {
						resolve(txHash.toString());
					}
				})
				.catch((err: unknown) => {
					reject(new Error(formatErrorMessage(err)));
				});
		});
	} catch (error) {
		const errorMessage = error instanceof Error ? error.message : String(error);
		if (errorMessage.includes("ECONNREFUSED") || errorMessage.includes("failed") || errorMessage.includes("timeout") || errorMessage.includes("Cannot connect")) {
			throw new Error(`Cannot connect to blockchain node at ${config.wsUrl}. Please start the contracts node:\n\nsubstrate-contracts-node --dev --tmp\n\nOr check if the node is running on the correct port.`);
		}
		throw new Error(formatErrorMessage(error));
	}
}

function getDefaultConfig(): InitConfig {
	// Uses env if provided; falls back to placeholders for local demo.
	return {
		wsUrl: process.env.NEXT_PUBLIC_WS_URL || "wss://westend-rpc.polkadot.io",
		contractAddress: process.env.NEXT_PUBLIC_CONTRACT_ADDRESS || "5Fxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
	};
}

function categoryToIndex(cat: "Docs" | "Builders" | "Governance" | "Ecosystem"): number {
	switch (cat) {
		case "Docs":
			return 0;
		case "Builders":
			return 1;
		case "Governance":
			return 2;
		case "Ecosystem":
			return 3;
		default:
			return 0;
	}
}

function indexToCategory(i: number): "Docs" | "Builders" | "Governance" | "Ecosystem" {
	switch (i) {
		case 0:
			return "Docs";
		case 1:
			return "Builders";
		case 2:
			return "Governance";
		case 3:
			return "Ecosystem";
		default:
			return "Docs";
	}
}


